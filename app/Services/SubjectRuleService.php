<?php


namespace App\Services;


use Exception;
use Faker\Provider\Uuid;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Support\Facades\DB;
use Throwable;
use YaangVu\Constant\CodeConstant;
use YaangVu\Constant\PermissionActionConstant;
use YaangVu\Constant\PermissionConstant;
use YaangVu\Constant\SubjectRuleConstant;
use YaangVu\Exceptions\BadRequestException;
use YaangVu\Exceptions\SystemException;
use YaangVu\LaravelBase\Services\impl\BaseService;
use YaangVu\SisModel\App\Models\impl\SubjectRuleSQL;
use YaangVu\SisModel\App\Traits\RoleAndPermissionTrait;

class SubjectRuleService extends BaseService
{
    use RoleAndPermissionTrait;

    private array $allowConflictRules = [SubjectRuleConstant::SAME_TEACHER, SubjectRuleConstant::DIFFERENT_TEACHER];

    /**
     * @inheritDoc
     */
    function createModel(): void
    {
        $this->model = new SubjectRuleSQL();
    }

    /**
     * @Author Edogawa Conan
     * @Date   Sep 06, 2021
     *
     * @param object $request
     *
     * @return Model
     * @throws Throwable
     */
    public function add(object $request): Model
    {
        if (!$this->hasPermission(PermissionConstant::subject(PermissionActionConstant::ADD)))
            throw new BadRequestException(__('forbidden.forbidden'), new Exception());

        DB::beginTransaction();

        // Validate
        if ($this->storeRequestValidate($request) !== true)
            return $this->model;

        $rules = $this->preAdd($request);

        try {
            $this->model->insert($rules);
            $this->postAdd($request, $this->model);
            DB::commit();

            return $this->model;
        }
        catch (Exception $e) {
            DB::rollBack();
            throw new SystemException($e->getMessage() ?? __('system-500'), $e);
        }
    }

    public function storeRequestValidate(object $request, array $rules = [], array $messages = []): bool|array
    {
        $rules = [
            'rules.*.type'                 => [
                'required',
                'in:' . implode(',', SubjectRuleConstant::ALL),
            ],
            'rules.*.subject_id'           => 'required|numeric|exists:subjects,id',
            'rules.*.relevance_subject_id' => 'required|numeric|exists:subjects,id',
        ];

        return parent::storeRequestValidate($request, $rules); // TODO: Change the autogenerated stub
    }

    public function checkConflictRules($attribute, $value, $fail, $request)
    {
        preg_match('/\.([^"]+)\./', $attribute, $selfIndex);

        foreach ($request->rules as $key => $rule) {
            if ($key == $selfIndex[1]) continue;

            if ($rule['type'] == $value ||
                (!in_array($value, $this->allowConflictRules) &&
                    !in_array($rule['type'], $this->allowConflictRules)))
                $fail("The $attribute is conflicted");
        }
    }

    public function preAdd(object $request)
    {
        $rules     = $request->rules;
        $createdBy = self::currentUser()?->id ?? null;
        foreach ($rules as $key => $rule) {
            $rules[$key][CodeConstant::UUID] = Uuid::uuid();
            $rules[$key]['group']            = Uuid::uuid();
            $rules[$key]['created_by']       = $createdBy;

            $reverseType = self::getReverseType($rule['type']);
            if($reverseType) {
                $reverseRule['type']                 = $reverseType;
                $reverseRule['subject_id']           = $rule['relevance_subject_id'];
                $reverseRule['relevance_subject_id'] = $rule['subject_id'];
                $reverseRule['group']                = $rules[$key]['group'];
                $reverseRule['created_by']           = $createdBy;
                $reverseRule[CodeConstant::UUID]     = Uuid::uuid();
                array_push($rules, $reverseRule);
            }
        }

        return $rules;
    }

    public static function getReverseType($type): string
    {
        return match ($type) {
            SubjectRuleConstant::BEFORE => SubjectRuleConstant::AFTER,
            SubjectRuleConstant::AFTER => SubjectRuleConstant::BEFORE,
            SubjectRuleConstant::FOLLOW => SubjectRuleConstant::PRECEDE,
            SubjectRuleConstant::PRECEDE => SubjectRuleConstant::FOLLOW,
            SubjectRuleConstant::SAME_TEACHER => SubjectRuleConstant::SAME_TEACHER,
            SubjectRuleConstant::DIFFERENT_TEACHER => SubjectRuleConstant::DIFFERENT_TEACHER,
            SubjectRuleConstant::SAME_PERIOD => SubjectRuleConstant::SAME_PERIOD,
            SubjectRuleConstant::DIFFERENT_PERIOD => SubjectRuleConstant::DIFFERENT_PERIOD,
            SubjectRuleConstant::SAME_TERM => SubjectRuleConstant::SAME_TERM,
            SubjectRuleConstant::DIFFERENT_TERM => SubjectRuleConstant::DIFFERENT_TERM,
            SubjectRuleConstant::CONSECUTIVE => SubjectRuleConstant::CONSECUTIVE,
        };
    }

    public function delete(int|string $id): bool
    {
        if (!$this->hasPermission(PermissionConstant::subject(PermissionActionConstant::DELETE)))
            throw new BadRequestException(__('forbidden.forbidden'), new Exception());

        $data = $this->get($id);
        if ($data['group']) {
            $subjectRules = $this->model->where('group', $data['group'])->get();
            foreach ($subjectRules as $rule) {
                $rule->delete();
            }
        }

        return true; // TODO: Change the autogenerated stub
    }

    public function preUpdate(int|string $id, object $request)
    {
        if (!$this->hasPermission(PermissionConstant::subject(PermissionActionConstant::EDIT)))
            throw new BadRequestException(__('forbidden.forbidden'), new Exception());

        parent::preUpdate($id, $request);
    }

    public function updateRequestValidate(int|string $id, object $request, array $rules = [],
                                          array      $messages = []): bool|array
    {
        $rules = [
            'rules.*.type'                 => [
                'required',
                'in:' . implode(',', SubjectRuleConstant::ALL),
            ],
            'rules.*.subject_id'           => 'required|numeric|exists:subjects,id',
            'rules.*.relevance_subject_id' => 'required|numeric|exists:subjects,id',
        ];

        return parent::storeRequestValidate($request, $rules); // TODO: Change the autogenerated stub
    }
}
