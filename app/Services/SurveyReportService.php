<?php
/**
 * @Author Edogawa Conan
 * @Date   Jun 09, 2022
 */

namespace App\Services;

use App\Exports\ExportSurvey;
use App\Helpers\RabbitMQHelper;
use Carbon\Carbon;
use DateTimeZone;
use Exception;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Pagination\LengthAwarePaginator;
use Illuminate\Support\Facades\Request;
use Illuminate\Validation\Rule;
use JetBrains\PhpStorm\ArrayShape;
use Maatwebsite\Excel\Facades\Excel;
use YaangVu\Constant\RoleConstant;
use YaangVu\Constant\StatusConstant;
use YaangVu\Constant\SurveyConstant;
use YaangVu\Exceptions\ForbiddenException;
use YaangVu\Exceptions\SystemException;
use YaangVu\LaravelBase\Helpers\QueryHelper;
use YaangVu\LaravelBase\Services\impl\BaseService;
use YaangVu\SisModel\App\Models\impl\SurveyAnswerNoSQL;
use YaangVu\SisModel\App\Models\impl\SurveyLogNoSQL;
use YaangVu\SisModel\App\Models\impl\SurveyNoSql;
use YaangVu\SisModel\App\Models\impl\UserNoSQL;
use YaangVu\SisModel\App\Traits\RoleAndPermissionTrait;

class SurveyReportService extends BaseService
{
    use RabbitMQHelper, RoleAndPermissionTrait;

    public static string $surveyId;
    public static string $surveyStatus;

    function createModel(): void
    {
        $this->model = new SurveyAnswerNoSQL();
    }

    public function preAdd(object $request)
    {
        $arrQuestion = $this->getArrQuestionViaSurveyId($request->survey_id);

        $rules = [
            'survey_id'       => 'required|exists:mongodb.surveys,_id',
            'anonymous'       => 'required|bool',
            'data'            => 'required',
            'data.*.type'     => 'required|in:' . implode(',', SurveyConstant::QUESTION_TYPE),
            'data.*.question' => 'required|' . Rule::in($arrQuestion),
        ];
        BaseService::doValidate($request, $rules);
        $surveyLog = SurveyLogNoSQL::query()->where('hash_code', $request->hash_code)->first();

        $request->merge([
                            'user_id' => $surveyLog->user_id ?? null,
                        ]);

        parent::preAdd($request); // TODO: Change the autogenerated stub
    }

    public function getArrQuestionViaSurveyId(string $surveyId): array
    {
        try {
            $survey = SurveyNoSql::query()->where('_id', $surveyId)->firstOrFail();
        } catch (Exception $e) {
            throw new SystemException($e->getMessage() ?? __('system-500'), $e);
        }
        $arrQuestion = [];
        foreach ($survey->survey_structure['questions'] as $value) {
            $arrQuestion[] = $value['question'];
        }

        return $arrQuestion;

    }

    public function postAdd(object $request, Model $model)
    {
        $user              = UserNoSQL::query()->with('userSql')->where('_id', $model->user_id)->first();
        $model->created_by = $user->userSql->id ?? null;
        $model->save();
        parent::postAdd($request, $model); // TODO: Change the autogenerated stub
    }

    public function reportSurveySummarize(object $request): object
    {
        $rules = [
            'survey_id' => 'required|exists:mongodb.surveys,_id'
        ];
        BaseService::doValidate($request, $rules);
        $survey        = SurveyNoSql::query()->where('_id', $request->survey_id)->first();
        $surveyAnswers = $this->model::query()->where('survey_id', $request->survey_id)->get()->unique('user_id');

        $arrAnswers = [];

        foreach ($surveyAnswers as $answers) {
            foreach ($answers->data as $answer) {
                $arrAnswers[$answer['question']]
                    = !empty($arrAnswers[$answer['question']]) ? $arrAnswers[$answer['question']] : (object)[];
                $arrAnswers[$answer['question']]->count
                    = !empty($arrAnswers[$answer['question']]->count) ? $arrAnswers[$answer['question']]->count : 0;

                $arrAnswers[$answer['question']]->countAnswerSurvey
                    = !empty($arrAnswers[$answer['question']]->countAnswerSurvey) ? $arrAnswers[$answer['question']]->countAnswerSurvey : 0;

                $arrAnswers[$answer['question']]->type = $answer['type'];
                if ($answer['type'] == SurveyConstant::SINGLE_LINE_TEXT || $answer['type'] == SurveyConstant::MULTI_LINE_TEXT) {
                    $arrAnswers[$answer['question']]->data[]
                        = $answer['answer'];
                    $arrAnswers[$answer['question']]->count++;
                    $arrAnswers[$answer['question']]->countAnswerSurvey++;
                } else {
                    $arrAnswers[$answer['question']]->data
                        = !empty($arrAnswers[$answer['question']]->data) ? array_merge($arrAnswers[$answer['question']]->data,
                                                                                       array_values((array)$answer['answer'])) : array_values((array)$answer['answer']);
                    $arrAnswers[$answer['question']]->count++;

                }
            }
        }
        $response = $questions = [];
        foreach ($survey->survey_structure['questions'] as $question) {
            $questions [] = $question;
        }

        foreach ($arrAnswers as $key => $answer) {
            $hasChoice = true;

            if ($answer->type == SurveyConstant::MULTI_LINE_TEXT || $answer->type == SurveyConstant::SINGLE_LINE_TEXT)
                $hasChoice = false;

            $arrAnswer      = array_count_values($answer->data);
            $totalAnswer    = array_sum($arrAnswer);
            $answerExpected = count($survey->user_respondent_id);
            $question       = collect($questions)->where('question', $key)
                                                 ->where('type', $answer->type)
                                                 ->first();
            $isRequire      = $question['require'] ?? null;
            if ($hasChoice) {
                $answerDetail = $question['choices'] ?? [];
                $countAnswer  = $percentChartAnswer = [];

                foreach ($answerDetail as $keyChoice => $valueChoice) {
                    foreach ($answer->data as $keyAnswer => $valueAnswer) {
                        if ($valueChoice['text'] == $answer->data[$keyAnswer]) {
                            $countAnswer [$keyChoice]
                                = isset($countAnswer [$keyChoice]) ? $countAnswer [$keyChoice] + 1 : 1;
                            $percentChartAnswer [$keyChoice]
                                = isset($countAnswer [$keyChoice]) ? $countAnswer [$keyChoice] * 100 / $totalAnswer : 0;
                        } else {
                            $countAnswer [$keyChoice]
                                = isset($countAnswer [$keyChoice]) ? $countAnswer [$keyChoice] : 0;
                            $percentChartAnswer [$keyChoice]
                                = isset($countAnswer [$keyChoice]) ? $countAnswer [$keyChoice] * 100 / $totalAnswer : 0;
                        }
                    }
                }
            } else {
                $percentChartAnswer = array_map(function ($val) use ($answerExpected) {
                    return $val * 100 / $answerExpected;
                }, [$answer->countAnswerSurvey, count($survey->user_respondent_id) - $answer->countAnswerSurvey]);

                $answerDetail = [
                    ['text' => 'Responded'],
                    ['text' => 'Not responded']
                ];
                $countAnswer  = [count($arrAnswer), count($survey->user_respondent_id) - count($arrAnswer)];
            }

            $response[] = (object)[
                'type'          => $answer->type,
                'title'         => $key,
                'label'         => $answerDetail,
                'data'          => $countAnswer,
                'percent_chart' => $percentChartAnswer,
                'count_answer'  => $answer->count,
                'has_choice'    => $hasChoice,
                'is_require'    => $isRequire
            ];
        }

        return (object)[
            'survey_title' => $survey->gerneral_information['title'],
            'answers'      => $response
        ];

    }

    #[ArrayShape(['question' => "mixed", 'count_answer' => "int|mixed", 'data' => "array"])]
    public function getDetailAnswerQuestion(object $request): array
    {
        $arrQuestion = $this->getArrQuestionViaSurveyId($request->survey_id);

        $ruleQuestion = [
            'question_title' => 'required|' . Rule::in($arrQuestion),
        ];
        BaseService::doValidate($request, $ruleQuestion);
        $surveyAnswer = $this->model::query()
                                    ->where('data.question', $request->question_title)
                                    ->where('survey_id', $request->survey_id)
                                    ->with('createdBy.userNoSql')
                                    ->paginate(QueryHelper::limit());

        $response = [
            'question'     => $request->question_title,
            'count_answer' => $this->model::query()
                                          ->where('data.question', $request->question_title)
                                          ->where('survey_id', $request->survey_id)
                                          ->count(),
            'data'         => []
        ];
        foreach ($surveyAnswer as $key => $value) {
            $email              = $value->createdBy->userNoSql->email ?? null;
            $fullName           = $value->createdBy->userNoSql->full_name ?? null;
            $answer             = collect($value->data);
            $answer             = array_values($answer->where('question', $request->question_title)->toArray());
            $respondentEmail
                                = !$value->anonymous ? $email : "Anonymous " . $key + 1 + ($request->page - 1) * ($request->limit);
            $respondentName     = !$value->anonymous ? $fullName : null;
            $response['data'][] = (object)[
                'no'               => $key + 1 + ($request->page - 1) * ($request->limit),
                'respondent_email' => $respondentEmail,
                'respondent_name'  => $respondentName,
                'responses'        => $answer[0]['answer']
            ];

        }

        return $response;
    }

    /**
     * @throws Exception
     */
    public function exportSurvey($id, $request): \Symfony\Component\HttpFoundation\BinaryFileResponse
    {
        $dataReportSurvey = $this->reportSurveyIndividual($id, $request);

        return Excel::download(new ExportSurvey($dataReportSurvey, $id), 'export_survey.xlsx');
    }

    /**
     * @Description
     *
     * @Author Admin
     * @Date   Jun 15, 2022
     *
     * @param $surveyId
     * @param $request
     *
     * @return array
     */
    #[ArrayShape(['responded' => "array", 'not_responded' => "array", 'status' => "mixed", 'count_respondent' => "int", 'count_not_respondent' => "int", 'sent_datetime' => "mixed", "responded_rate" => "float|int"])]
    public function reportSurveyIndividual($surveyId, $request): array
    {
        $isTeacher = $this->hasAnyRole(RoleConstant::TEACHER);
        $isGod     = $this->isGod();
        if (!$isTeacher && !$isGod) {
            throw new ForbiddenException(__('role.forbidden'), new Exception());
        }
        $request->merge(['survey_id' => $surveyId]);
        $rules = [
            'sending_status' => 'in:' . StatusConstant::RESPONDED . ',' . StatusConstant::NOT_RESPONDED,
            'survey_id'      => 'exists:mongodb.surveys,_id',
        ];
        BaseService::doValidate($request, $rules);
        $sendingStatus = $request->sending_status ?? null;
        $isExport      = $request->is_export ?? null;
        $querySurvey   = SurveyNoSql::query()->where('_id', $surveyId);
        if (!$isGod) {
            $user = BaseService::currentUser()->userNoSql->_id;
            $querySurvey->where('create_by', $user)
                        ->where('role_name', RoleConstant::TEACHER);
        }
        $survey = $querySurvey->first();

        if (!isset($survey)) {
            throw new ForbiddenException(__('role.forbidden'), new Exception());
        }
        $surveyAnswers                    = SurveyAnswerNoSQL::query()
                                                             ->where('survey_id', $surveyId)
                                                             ->whereNotNull('user_id')
                                                             ->get()
                                                             ->toArray();
        $userIdsResponded                 = array_unique(array_column($surveyAnswers, 'user_id'));
        $collectSurveyAnswers             = collect($surveyAnswers);
        $userIdsRespondedAndNotRespondent = $survey->user_respondent_id ?? [];
        $userIdsNotRespondent             = array_diff($userIdsRespondedAndNotRespondent, $userIdsResponded);
        $countNotRespondent               = UserNoSQL::query()->whereIn('_id', $userIdsNotRespondent)->count();
        $countRespondent                  = UserNoSQL::query()->whereIn('_id', $userIdsResponded)->count();
        $usersNotResAndRes                = UserNoSQL::query()->whereIn('_id', $userIdsRespondedAndNotRespondent)
                                                     ->when($sendingStatus == StatusConstant::NOT_RESPONDED,
                                                         function ($q) use ($userIdsNotRespondent) {
                                                             $q->whereIn('_id', $userIdsNotRespondent);
                                                         })
                                                     ->when($sendingStatus == StatusConstant::RESPONDED,
                                                         function ($q) use ($userIdsResponded) {
                                                             $q->whereIn('_id', $userIdsResponded);
                                                         })
                                                     ->paginate(queryHelper::limit());
        $exportUsersNotResAndRes          = [];
        if ($isExport == true) {
            $exportUsersNotResAndRes = UserNoSQL::query()->whereIn('_id', $userIdsRespondedAndNotRespondent)
                                                ->when($sendingStatus == StatusConstant::NOT_RESPONDED,
                                                    function ($q) use ($userIdsNotRespondent) {
                                                        $q->whereIn('_id', $userIdsNotRespondent);
                                                    })
                                                ->when($sendingStatus == StatusConstant::RESPONDED,
                                                    function ($q) use ($userIdsResponded) {
                                                        $q->whereIn('_id', $userIdsResponded);
                                                    })
                                                ->get()->transform(function ($item, $key) use (
                    $collectSurveyAnswers, $userIdsNotRespondent, $userIdsResponded, $survey
                ) {
                    $key = $key + 1;
                    $surveyAnswerRespondent
                         = $collectSurveyAnswers
                        ->where('user_id', $item->_id)
                        ->first();

                    return $this->getUserRespondentAndNotRespondent($item,
                                                                    $userIdsNotRespondent,
                                                                    $userIdsResponded,
                                                                    $survey,
                                                                    $surveyAnswerRespondent, $key);
                })->toArray();
        }
        $page = $request->page ?? 0;
        if ($page >= 1) {
            $page = ($page - 1) * 10;
        }
        $itemsTransformed = $usersNotResAndRes->getCollection()
                                              ->map(function ($item, $key) use (
                                                  $userIdsNotRespondent,
                                                  $userIdsResponded,
                                                  $survey,
                                                  $collectSurveyAnswers,
                                                  $page
                                              ) {
                                                  $surveyAnswerRespondent
                                                       = $collectSurveyAnswers
                                                      ->where('user_id', $item->_id)
                                                      ->first();
                                                  $key = $key + 1;
                                                  if ($page > 1) {
                                                      $key = $key + 1;
                                                  }
                                                  $key = $key + $page;

                                                  return $this->getUserRespondentAndNotRespondent($item,
                                                                                                  $userIdsNotRespondent,
                                                                                                  $userIdsResponded,
                                                                                                  $survey,
                                                                                                  $surveyAnswerRespondent,
                                                                                                  $key
                                                  );
                                              })->toArray();
        $paginateUsers    = $this->paginateCollection($usersNotResAndRes,
                                                      $itemsTransformed);
        $countUserRespondedAndNotRespondent
                          = count($userIdsRespondedAndNotRespondent) == 0 ? 1 : count($userIdsRespondedAndNotRespondent);
        $respondedRate
                          = round(($countRespondent / $countUserRespondedAndNotRespondent * 100),
            2);

        return [
            'users'                     => $isExport == true ? $exportUsersNotResAndRes : $paginateUsers,
            'status'                    => $survey->status,
            'title_survey'              => $survey->gerneral_information['title'],
            'count_respondent'          => $countRespondent,
            'count_not_respondent'      => $countNotRespondent,
            "responded_rate"            => $respondedRate,
            "appearance_report_setting" => $survey->gerneral_information['appearance_report_setting'] ?? null,
        ];
    }

    /**
     * @Description
     *
     * @Author Admin
     * @Date   Jun 20, 2022
     *
     * @param $value
     * @param $userNotRes
     * @param $userRes
     * @param $survey
     * @param $surveyAnswerRespondent
     * @param $key
     *
     * @return array
     */
    function getUserRespondentAndNotRespondent($value, $userNotRes, $userRes, $survey, $surveyAnswerRespondent,
                                               $key): array
    {

        $userAnswers    = [];
        $userNotAnswers = [];
        if (in_array($value->_id, $userNotRes)) {
            $userNotAnswers = $this->formatUserRespondentAndNotRespondent($value, StatusConstant::NOT_RESPONDED,
                                                                          $survey,
                                                                          $surveyAnswerRespondent, $key);
        }
        if (in_array($value->_id, $userRes)) {
            $userAnswers = $this->formatUserRespondentAndNotRespondent($value, StatusConstant::RESPONDED, $survey,
                                                                       $surveyAnswerRespondent, $key);
        }

        return array_merge($userAnswers, $userNotAnswers);
    }

    /**
     * @Description
     *
     * @Author Admin
     * @Date   Jun 20, 2022
     *
     * @param $data
     * @param $status
     * @param $survey
     * @param $surveyAnswerRespondent
     * @param $key
     *
     * @return array
     */
    #[ArrayShape(['role_name' => "mixed", 'avatar_url' => "mixed", 'email' => "mixed", 'student_code' => "mixed", 'name' => "mixed", 'status' => "", 'data_answers' => "mixed", "submission_datetime" => "null|string", 'sent_datetime' => "mixed"])]
    function formatUserRespondentAndNotRespondent($data,
                                                  $status,
                                                  $survey,
                                                  $surveyAnswerRespondent,
                                                  $key): array
    {

        $isAnonymous = $survey->gerneral_information['appearance_report_setting'] ?? null;

        return [
            'role_name'           => $isAnonymous == true ? null : $data->role_names ?? null,
            'avatar_url'          => $isAnonymous == true ? null : $data->usersNotRespondent->avatar_url ?? null,
            'email'               => $isAnonymous == true ? null : $data->email ?? null,
            'student_code'        => $isAnonymous == true ? null : $data->usersNotRespondent->student_code ?? null,
            'name'                => $isAnonymous == true ? 'Anonymous ' . $key : $data->full_name ?? null,
            'status'              => $status,
            'data_answers'        => $surveyAnswerRespondent['data'] ?? null,
            "submission_datetime" => isset($surveyAnswerRespondent['updated_at']) ? Carbon::parse($surveyAnswerRespondent['updated_at'])
                                                                                          ->format('Y-m-d H:i:s') : null,
            'sent_datetime'       => $survey->sent_date?->toDateTime()->format('Y-m-d H:i:s'),
        ];
    }

    /**
     * @Description
     *
     * @Author Admin
     * @Date   Jun 20, 2022
     *
     * @param $collection
     * @param $itemsTransformed
     *
     * @return LengthAwarePaginator
     */
    function paginateCollection($collection, $itemsTransformed): LengthAwarePaginator
    {
        return new LengthAwarePaginator(
            $itemsTransformed,
            $collection->total(),
            $collection->perPage(),
            $collection->currentPage(), [
                'path'  => Request::url(),
                'query' => [
                    'page' => $collection->currentPage()
                ]
            ]
        );
    }
}
